//ANANDA BADARI - 903279508
#include <stdio.h>
#include <stdlib.h>
#include "gba.h"
#include "game.h"
                    /* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/title.h"
#include "images/winner.h"
#include "images/gameover.h"


                    /* TODO: */
// Add any additional states you need for your app.
typedef enum {
    START,
    INSTR,
    PLAY,
    WIN,
    LOSE,
    END,
} GBAState;

int numblocks = 0;

struct block blocks[ROWS*COLS];
u16 colors[5] = {RED, ORANGE, YELLOW, GREEN, BLUE};
struct gamebat bat= {WIDTH/2, 30, 1};
int score = 0;
struct gameball ball = {WIDTH/2, HEIGHT/2, -1, 1, 0, 0};
int level = 1;
char* testing = "TEST";
int slow = 1;

void drawBlock(struct block curr){
    drawRectDMA(curr.x, curr.y, 24, 15, curr.color);
    
}

void drawBlocks(void) {
    for(int i = 0; i < ROWS; i++){
        for(int j = 0; j < COLS; j++){
            if(blocks[OFFSET(j, i, COLS)].hit == 0){
                drawBlock(blocks[OFFSET(j, i, COLS)]);
            }
        }
    }
}

void drawBat(u16 color){
    drawRectDMA(bat.x, 145, bat.length, 5, color);
}

void drawBall(u16 color){
    drawRectDMA(ball.x, ball.y, 5, 5, color);
}

int st; //-1 means go to LOST state
void moveBall(void) {
    drawBall(BLACK);
    if(ball.x >= 235 || ball.x <= 0) {
        ball.vx *= -1;
    }
    if(ball.y <= 0) {
        ball.vy *= -1;
    }
    if(ball.y >= 160){
        st = -1;
        ball.vx = 0;
        ball.vy = 0;
    }
    ball.x += ball.vx;
    ball.y += ball.vy;
    drawBall(WHITE);
}

void clearNotifs(void){
    drawRectDMA(0, 151, WIDTH, 10, BLACK);
}

void display(void){
    clearNotifs();
    char buffer[20];
    sprintf(buffer, "Speed: %d", bat.speed);
    drawString(2, 151, buffer, RED);

    sprintf(buffer, "Score: %d", score);
    drawString(62, 151, buffer, GOLD);
    drawString(122, 151, testing, BLUE);
    drawString(184, 151, "BREAKOUT!", WHITE);
}

// void showscore(void){
//     char buffer[20];
//     sprintf(buffer, "Score: %d", score);
//     drawString(0, 85, buffer, GOLD);
// }

void checkCollision(void) {
    //check collision with bat
    int mofe = 3;
    if(ball.x > (bat.x - mofe) && ball.x < (bat.x + bat.length + mofe) && ball.y >= 145 - mofe){
        ball.vy *= -1;
        moveBall();
    }
    //check collision with block
    if(ball.y <= 74){
        int col = ball.x/24;
        int row = ball.y/15;
        if(blocks[OFFSET(col, row, COLS)].hit == 0){
            blocks[OFFSET(col, row, COLS)].hit = 1;
            blocks[OFFSET(col, row, COLS)].color = BLACK;
            ball.vy *= -1;
            numblocks--;
            if(numblocks == 0){
                st = 1;
            }
            drawBlock(blocks[OFFSET(col, row, COLS)]);
            score += 10;
            moveBall();
        }
    }
}

int count = 0;
void inplay(void) {
    display();
    drawBlocks();
    drawBat(WHITE);
    drawBall(WHITE);
    checkCollision();
    if(count % slow == 0){
        moveBall();
        count = 0;
    }
    count++;
}

void setup(void) {
    numblocks = 0;
    for(int i = 0; i < ROWS; i++){
        u16 color = colors[i];
        for(int j = 0; j < COLS; j++){
            int hit = randint(0, level);
            numblocks += hit == 0 ? 1 : 0;
            blocks[OFFSET(j, i, COLS)].x = j * 24;
            blocks[OFFSET(j, i, COLS)].y = i * 15;
            blocks[OFFSET(j, i, COLS)].hit = hit;
            blocks[OFFSET(j, i, COLS)].color = color;
        }
    }
    st = 0;
    bat.x = WIDTH/2;
    ball.x = WIDTH/2;
    ball.y = HEIGHT/2;
    ball.vx = -1;
    ball.vy = 1;
    testing = "";
    score = 0;
    inplay();

}

int p;
void pause(void) {
    u16 color = GOLD;
    if(ball.vx == 0 && ball.vy == 0){
        ball.vx = ball.tvx;
        ball.vy = ball.tvy;
        color = BLACK;
        p = 0; //not paused
    } else {
        ball.tvx = ball.vx;
        ball.tvy = ball.vy;
        ball.vx = 0;
        ball.vy = 0;
        p = 1; //paused
    }
    drawCenteredString(0, 0, WIDTH, HEIGHT, "PAUSED.", color);
}

int main(void) {
                    /* TODO: */
    // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;

    // Save current and previous state of button input.
    u32 previousButtons = BUTTONS;
    u32 currentButtons = BUTTONS;

    // Load initial game state
    GBAState state = START;

    u16 c1 = GOLD;
    u16 c2 = GOLD;

    char in[100] = "INSTRUCTIONS";
    char i1[100] = "UP/DOWN to increase or decrease";
    char i12[100] = "speed of the paddle.";
    char i2[100] = "LEFT/RIGHT to move paddle.";
    char i3[100] = "A (z) to pause and unpause the game.";
    char i4[100] = "B (x) to switch game modes.";
    char i5[100] = "L (a) for fast mode.";
    
    while (1) {
        currentButtons = BUTTONS; // Load the current state of the buttons
                    /* TODO: */
        // Manipulate the state machine below as needed //
        // NOTE: Call waitForVBlank() before you draw

        waitForVBlank();
        if(KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            fillScreenDMA(BLACK);
            state = START;
        }
        switch(state) {
            case START:
                drawFullScreenImageDMA(title);

                if(KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    c1 = GOLD;
                    c2 = GOLD;
                    slow = 2;
                    bat.speed = 1;
                    level = 1;
                    state = INSTR;
                    fillScreenDMA(BLACK);
                }
                break;
            case INSTR:
                if(KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) {
                    bat.speed = 1;
                    if(level == 1){
                        c1 = BLUE;
                        level = 3;
                    } else {
                        c1 = GOLD;
                        level = 1;
                    }
                }
                if(KEY_JUST_PRESSED(BUTTON_L, currentButtons, previousButtons)) {
                    if(slow == 1){
                        c2 = GOLD;
                        slow = 2;
                        bat.speed = 1;
                    }
                    else {
                        c2 = RED;
                        slow = 1;
                        bat.speed = 2;
                    }
                }
                drawCenteredString(0, -60, WIDTH, HEIGHT, in, WHITE);
                drawCenteredString(0, -40, WIDTH, HEIGHT, i1, GOLD);
                drawCenteredString(0, -28, WIDTH, HEIGHT, i12, GOLD);
                drawCenteredString(0, -10, WIDTH, HEIGHT, i2, GOLD);
                drawCenteredString(0, 5, WIDTH, HEIGHT, i3, GOLD);
                drawCenteredString(0, 20, WIDTH, HEIGHT, i4, c1);
                drawCenteredString(0, 35, WIDTH, HEIGHT, i5, c2);
                drawCenteredString(0, 60, WIDTH, HEIGHT, "START TO PLAY GAME.", WHITE);

                if(KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = PLAY;
                    fillScreenDMA(BLACK);
                    setup();
                }
                
                break;
            case PLAY:
                inplay();
                waitForVBlank();
                if(KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
                    pause();
                }
                if(p == 1) {
                    break;
                }
                if(KEY_DOWN(BUTTON_LEFT, currentButtons)) {
                    drawBat(BLACK);
                    bat.x = (bat.x - bat.speed);
                    if(bat.x < 0){
                        bat.x = 0;
                    }
                }
                if(KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
                    drawBat(BLACK);
                    bat.x = (bat.x + bat.speed);
                    if(bat.x > WIDTH - bat.length){
                        bat.x = WIDTH - bat.length;
                    }
                }
                if(KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
                    bat.speed++;
                    if(bat.speed > 10){
                        bat.speed = 10;
                    }
                    display();
                }
                if(KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
                    bat.speed--;
                    if(bat.speed < 1) {
                        bat.speed = 1;
                    }
                    display();
                }

                if(st != 0){
                    if(numblocks == 0) {
                        state = WIN;
                    } else {
                        state = LOSE;
                    }
                } 
                // playgame();
                // state = ?
                break;
            case WIN: 
                drawCenteredString(0, 0, WIDTH, HEIGHT, "WINNER WINNER", BLUE);
                drawCenteredString(0, 10, WIDTH, HEIGHT, "CHICKEN DINNER!", BLUE);
                // win();
                // state = ?
                display();
                drawCenteredString(0, 30, WIDTH, HEIGHT, "PRESS A (z) TO CONTINUE", WHITE);
                if(KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
                    fillScreenDMA(BLACK);
                    state = END;
                }

                break;
            case LOSE:
                drawCenteredString(0, 15, WIDTH, HEIGHT, "HA LOSER!", RED);
                drawCenteredString(0, 30, WIDTH, HEIGHT, "PRESS SELECT TO RESTART", WHITE);
                // lose();
                // state = ?
                drawImageDMA(50, 108, GAMEOVER_WIDTH, GAMEOVER_HEIGHT, GAMEOVER);
                if(KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                }
                display();
                break;
            case END:
                drawFullScreenImageDMA(WINNER);
                // char buffer[20];
                // showscore();
                // sprintf(buffer, "Final Score: %d", score);
                // drawCenteredString(0, 0, WIDTH, HEIGHT, buffer, WHITE);
                break;
        }
        previousButtons = currentButtons; // Store the current state of the buttons
    }
    return 0;
}
